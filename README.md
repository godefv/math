# What is it ?
This is a c++ math library. It provides :

* **abstract mathematical objects**

  groups, vector spaces, algebras, etc.

* **some specific instances of such objects**

  geometric algebra, which includes complex numbers, quaternions, and much more.
  geometric transformation groups generated by rotations, translations, homothecies. TODO: inversions

* **coordinate free geometry** 

  In some math libraries, points and vectors are defined with something like `Vector3d{1., 2., 0.}`. In this case, the compiler doesn't know in which frame those coordinates are (and maybe you don't either).

  Instead, using this library, you will use meaningful directions like `1.*up+2.*east+0.*north`. The directions `up`, `east`, `north` will have distinct types with zero memory footprint, so that there is no overhead and the compiler known exaclly what frame is used.

  Moreover, in the above example `0.*north` is superfluous, so you can just write `up+2*east`, which takes less memory and is faster to process at runtime because ony 2 numbers will be used instead of 3. The library will take care of returning the best types in terms of memory and geometric signification for every math operation or function. Another important example is the composition of geometric transformations : any composition of rotations will produce a rotation (and be stored internally as a quaternion), but a composition of any number of rotations with any number of translations in any order will generate a type storing a single rotation followed by a single translation (stored internally as a quaternion and a vector), and similar simplifications are made if you add homothecies in the mix, always generating the simplest possible type, which will also limit the number of different c++ types in the whole program. 

  If you have several frames, don't bother changing frame explicitly, just define your new frames in terms of the previous ones and use adequate frame vectors directly : `1.3*my_frame_x + 2.4*my_other_frame_z`. The internal representation of every point and geometric transformation will automatically be converted in the main frame, so any tranformation can be applied safely on any point. 

# Examples
```
#include"geometry/point_transform.h"

using namespace math::geometry::literals;
using math::half_turn;
using math::ratio;
using math::integer;

static constexpr auto x="x"_direction_positive; 
static constexpr auto y="y"_direction_positive; 
static constexpr auto z="z"_direction_positive; 
static constexpr auto t="t"_direction_negative; 

auto constexpr O=math::geometry::default_origin;    //stores nothing
auto constexpr A=math::geometry::make_point(x+y);   //stores nothing
auto constexpr B=math::geometry::make_point(x+y+z); //stores nothing
auto constexpr C=math::geometry::make_point(ratio<-1,3>*x+ratio<2,3>*y+ratio<3,5>*t); //stores nothing
auto           D=math::geometry::make_point(24.0*x-18.0*y+1.5*z); //stores 3 double

auto constexpr translation=math::geometry::translation_t{integer<4>*x}; //stores nothing
auto constexpr homothecy=math::geometry::make_homothecy(A,ratio<1,4>); //converted to an homothecy centered on O followed by a translation, stores a ratio and a vector (nothing in this case because everything is known at comile time)
auto constexpr rotation1=math::geometry::make_point_rotation(O,math::geometry::simple_rotation_t{math::geometry::plane(y,z), ratio<1,2>*half_turn}); //stores nothing
auto constexpr rotation2=math::geometry::make_point_rotation(C,math::geometry::simple_rotation_t{math::geometry::plane(x,t), ratio<235,1279>}); //a boost is a rotation in a mixed plane (containing both positive and negative directions) ; stores nothing
auto rotation3=math::geometry::make_point_rotation(D,math::geometry::simple_rotation_t{math::geometry::plane(x,y), 0.35*half_turn}); //converted to a rotation centered on O followed by a translation (stored as an angle and a 3D vector, so 4 double)

auto transform=(translation,rotation1,homothecy,rotation3); //converted to an homothecy followed by a rotation followed by a translation  
auto transformed_C=transform(C); //the homothecy is applied (no op), then the rotation is applied (only the x and y components of C are affected, the t component is still a compile-time value at this point, minimal amount of computation is done), then the translation is applied (x,y,z components are computed and stored in 3 double, t component is still a compile-time value (the transformation operates in the (x,y,z) space, except for a dilation with a compile-time factor))
```

# Implementation

## strong typing
Mathematical objects and expressions are represented by c++ types. Operations on those types are made by constexpr functions.
It can effectively turn your compiler into a symbolic math software, in which case the resulting program would only print the result that have been computed at compile time. 
Most program will of course use runtime values, but the library will try to do everything it can do at compile time, so prefer using `math::integer<2>` and `math::ratio<1,2>` instead of `2.0` and `0.5` in your code.

## extensible dimensions
No need to specify in advance a space in which to work, new types are generated if new dimensions appear in an expression. If you write `auto a=3*x+4*y`, `a` stores two values in a type generated from the expression `"double*x+double*y"`. Then, writing `a+2.5*z` will just generate a larger type holding three values (assuming `z` is not a combination of `x` and `y`).

## small and easy to read
It is small because it exploits work from mathematicians. They have put many concepts into the most beautiful form they could find : both as general and as simple as possible, which means factorized and simple code.
The library also uses c++17 with concepts, which provides human friendly template programming.

## unit tests
They are a good place to look for examples.
They make sure things work as intended.
When testing runtime values, use only values which have a finite representation in base 2, because strict equality is checked.
